- 142:
    - Vamos a actualizar nuestro user entity con una nueva propiedad ( admin: boolean ) que por defecto sea true
    - Vamos a crear ahora un admin guard, cogemos el currentuser ( si no hay devolvemos false ), y devolvemos user.admin

- 143:
    - usamos el admin guard en el patch
    - Test! --> No funciona

- 144:
    - Meter pantallazo sobre el flow en el Trello

- 145:
    - Vamos a crear un nuevo file dentro de users llamado current-user.middleware.ts

        @I jectable()
    - export class CurrentUserMiddleware implements NestMiddleware {
        constructor(private usersService: UsersService){}

        async use(request: Request, response: Response, next: NextFunction){
            const { userId }= request.session || {}
            if(userId){
                const user = await this.usersService.getById(userId);
                // @ts-ignore
                req.currentUser = user
            }

            next();
        }
    }

    - Ahora en UsersModule, vamos a utiliar el mismo approach que cuando usamos el CookieSession.
        - configure(.....){
            consumer.apply(currentusermiddleware).forRoutes('*')
        }

        - Borramos el currentuserInterceptor, los imports y el archivo en si
    - Test again it should work!

- 146:
    - Nada, no importante

- 147:
    - Vamos a crear un nuevo dto en el que se especifiquen get-estimation.dto.ts que tenga los mismos campos que las de crearReportDto pero sin el precio.
    - Creamos el route handler.
    - comprobamos que al probar, nos da un error porque recibimos las cosas como string en vez de como number.

- 148:
    - En el get estimate, vamos a usar el decorator transform para, en todas las propiedades que sean number, hacer un parseInt(al valor de la request. { value } => parseInt(value))
    - Para latitude y longitud vamos a hacer parseFloat en vez de parseInt
    - Comprobamos que todo esta bien ya.

- 149:
    - Nada

- 150 & 151:
    - Creamos el metodo en el servicio de reports para obtener los reports.
    - Dentro del sericio, vamos a hacer lo siguiente:
        return this.repo.createQueryBuilder(
                .select('ABV(price)', 'price')
                .where('make = :make', { make: estimateDto.make })
                .andWhere('model = :model', { model: estimateDto.model })
                .andWhere('lng - :lng BETWEEN -5 AND 5', { lng: estimateDto.lng })
                .andWhere('lat - :lat BETWEEN -5 AND 5', { lat: estimateDto.lat })
                .andWhere('year - :year BETWEEN -3 AND 3', { lat: estimateDto.year })
                .andWhere('approved is TRUE')
                .orderBy('ABS(mileage - :mileage)', 'DESC')
                .setParameters({ estimateDto.mileage })
                .limit(3)
                .getRawOne()
        )

- 152:
    - Test

- 153:
    Nada

- 154:
    - En el env.development y env.test vamos a añadir un COOKIE=randomstringhere
    - Vamos a actualizar en el app.module.ts vamos a añadir un constructor: constructor(configService: configService){}
    - En la config del cookie session cambiamos keys por keys: [this.configService.get('COOKIE')]